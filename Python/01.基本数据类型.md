

- [基本数据类型](#基本数据类型)
  - [1 整数](#1-整数)
    - [（1）比较运算符（<、>、<=、>=、 ==、 != ）](#1比较运算符---)
    - [（2）算术运算符（+、-、*、/、%、**、//）](#2算术运算符-)
    - [（3）赋值运算符（ = ）](#3赋值运算符--)
    - [（4）位运算符（&、|、^、~、>>、<<）](#4位运算符)
    - [（5）转进制 （int、bin、oct、hex）](#5转进制-intbinocthex)
    - [（6）判断奇偶（&1、%2）](#6判断奇偶12)
  - [2 浮点数](#2-浮点数)
    - [（1）书写形式](#1书写形式)
    - [（2）最大值](#2最大值)
    - [（3）无穷小、大](#3无穷小大)
    - [（4）取整](#4取整)
    - [（5）计算的不精确](#5计算的不精确)
  - [3 复数](#3-复数)
  - [4 布尔值/布尔类型](#4-布尔值布尔类型)
    - [（1）布尔类型（True、False）](#1布尔类型truefalse)
    - [（2）布尔运算（and、or、not）](#2布尔运算andornot)
  - [5 空值](#5-空值)
  - [6 字符串](#6-字符串)
    - [（1）新建](#1新建)
    - [（2）拆分（.split）](#2拆分split)
    - [（3）拼接（+）](#3拼接)
    - [（4）代替（.replace）](#4代替replace)
    - [（5）删除（.strip）](#5删除strip)
    - [（6）查找（.find、.index）](#6查找findindex)
    - [（7）计数（.count）（子字符串）](#7计数count子字符串)
    - [（8）字符串格式化(.format、zfill)](#8字符串格式化formatzfill)
    - [（9）比较](#9比较)
    - [（10）转义字符（\）](#10转义字符)
    - [（11）str  <==>  bytes](#11str----bytes)
    - [（12）str  <==>  list](#12str----list)
    - [（13）正则（re.search）](#13正则research)
    - [（14）判断字符串中是否有汉字](#14判断字符串中是否有汉字)
    - [（15）编辑距离（Levenshtein）](#15编辑距离levenshtein)
  - [7 类型判断（type、isinstance）](#7-类型判断typeisinstance)



（github: https://github.com/songxia928/Python）

# 基本数据类型

-------------------
## 1 整数

Python 整数数据类型，简称整型，在 Python 中用 int表示。整数指的是没有小数部分的数字，在 Python 中的整数包括正整数、0（数字零） 和负整数。
在 Python 中整型的取值范围是无限的（整数具有无限的精度）。


- **含义：** int() 函数用于将一个字符串或数字转换为整型。
- **函数原型：** int(x, base=10)
- **参数：**
    -    x: 字符串或数字。
    -    base: 进制数，默认十进制。
- **返回：** 整型


### （1）比较运算符（<、>、<=、>=、 ==、 != ）

>**注意：** python 中比较运算符并不仅仅只适用于整数。浮点数、字符串、对象都是可以使用。

**（a）比较大小 （<、>、<=、>=）**

```python
a = 10

# ==== 判断 a 是否在[0,20) 内
b = 0 <= a < 20    # True

# ==== 判断 a 大于等于 20
c = 20 <= a        # False
```

**（b）比较相等 （==、 !=）**
```python
a = 10

b = a == 10    # True
c = a == 20    # False
```


### （2）算术运算符（+、-、*、/、%、**、//）

```python
 +	  # 加：两个对象相加	 20+10=30
 -	  # 减：一个数减去另外一个数	 20-10=10
 *	  # 乘：两数相乘或返回一个被重复若干次的字符串	 20*10=200
 /	  # 除：两个数相除	 20/10=2
 %	  # 取模：返回两个数相除的余数	 20%10=0
 **	  # 幂：返回某一个数的若干次幂	20**3,即8000
 //	  # 取整：返回两数相除后所得商的整数部分	 7//3=2,7.0//2.0=3.0
```
> **注意：**  python中计算多少次幂，是用 ** ， 不是用 ^， ^ 是按位异或运算符。


### （3）赋值运算符（ = ）
赋值运算符用 = 表示，执行顺序是从右至左。
```python
# ==== 直接赋值
a = 2+3

# ==== 链式赋值
a = b = c = 10  # 相当于 a = 10; b = 10; c = 10

# ==== 参数赋值
a += b          # 相当于 a = a+b

# ==== 系列解包赋值
a, b, c = 1, 2, 3

# ==== 交换变量赋值
a, b = b, a
```

### （4）位运算符（&、|、^、~、>>、<<）

```python
&   # 按位与运算符，参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0；
|   # 按位或运算符，只要对应的二个二进位有一个为1时，结果位就为1；
^   # 按位异或运算符，当两对应的二进位相异时，结果为1；
~   # 按位取反运算符，对数据的每个二进制位取反，即把1变为0，把0变为1；
>>   # 右移动运算符，把 >> 左边的运算数的各二进位全部右移若干位，>> 右边的数指定移动的位数；
<<   # 左移动运算符，运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0。
```
```python
a = 21        # 010101
b = 6         # 000110
a_ = bin(a)   
b_ = bin(b)

c = a&b   # 4,   000100
d = a|b   # 23,  010111
e = a^b   # 19,  010011
f = ~a    # -22, 101010
g = a<<2  # 84,  010100
h = a>>2  # 5,   000101

c_ = bin(c)
d_ = bin(d)
e_ = bin(e)
f_ = bin(f)
g_ = bin(g)
h_ = bin(h)
```
> **注意：**  运行  a_ & b_  或  '0b010101' & '0b000110'  或  '010101' & '000110' 均会报错，因为这些输入均为字符串，位运算符不支持字符串类型。



### （5）转进制 （int、bin、oct、hex）
**（a） 十 ==> 二（bin）**
```python
a = 10
b = bin(a)  # 0b1010 ， <class 'str'>  
```

**（b） 二 ==> 十（int）**

```python
a = int('1010',2)    # 10
b = int('0b1010',2)  # 10
```

**（c） 十 ==> 八（oct）**
```python
a = oct(15)  # 0o17， <class 'str'>
```
**（d） 八 ==> 十（int）**
```python
a = int('17',8)    # 15
b = int('0o17',8)  # 15
```

**（e） 十 ==> 十六（hex）**
```python
a = hex(25)  # 0x19 <class 'str'>
```
**（f） 十六 ==> 十（int）**
```python
a = int('19',16)     # 25
b = int('0x19',16)   # 25
c = int('ff',16)     # 255 = 15*16 + 15 
d = int('0xff',16)   # 255
```

### （6）判断奇偶（&1、%2）
```python
# ==== & 1 : 和1 按位与
a = 3 & 1       # 1
a = 2 & 1       # 0

# ==== % 2 : 对2 求余
a = 3 % 1       # 1
a = 2 % 1       # 0
```

-------------------
## 2 浮点数

在编程语言中，小数通常以浮点数的形式存储。浮点数和定点数是相对的：小数在存储过程中如果小数点发生移动，就称为浮点数；如果小数点不动，就称为定点数。
Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。
### （1）书写形式

**（a） 十进制形式**
这种就是我们平时看到的小数形式，例如 34.6、346.0、0.346。

**（b） 指数形式**
指数形式的写法为：aEn 或 aen 。 整个表达式等价于 a×10n。
- **参数：**
a ：为尾数部分，是一个十进制数；
n ：为指数部分，是一个十进制整数；
E或e ：是固定的字符，用于分割尾数部分和指数部分。
>**注意: **只要写成指数形式就是小数，即使它的最终值看起来像一个整数。例如 14E3 等价于 14000，但 14E3 是一个小数。
```python
a = 20e3     # 20000.0
b = 20e+3    # 20000.0

c = 20e-3    # 0.02
d = -20e-3   # -0.02
```

### （2）最大值
```python
import sys
a = sys.float_info.max   # 1.7976931348623157e+308
b = sys.float_info.min   # 2.2250738585072014e-308
```

### （3）无穷小、大
```python
num = float('-inf')   # 无穷小
num = float('inf')   # 无穷大

# 整数无穷大小呢, 没有：int('inf')

```

### （4）取整

**（a） math.ceil**
```python
import math   # This will import math module

math.ceil(-45.17) #  -45
math.ceil(100.12) # 101
math.ceil(100.72) #  101
math.ceil(math.pi) #  4
```


**（b）round**

```python

round(70.23456) #  70 
round(56.659,1) #  56.7 
round(80.264, 2) #  80.26 
round(100.000056, 3) #  100.0 
round(-100.000056, 3) #  -100.0
```

### （5）计算的不精确
```python
a = 12.3 * 0.1   # 1.2300000000000002
b = 1.23         # 1.23
c = a == b       # False
```

-------------------
## 3 复数

复数（Complex）是 Python 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。

复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以j或者J作为后缀，具体格式为：
a + bj # a 表示实部，b 表示虚部

```python
c1 = 1 + 0.1j  
c2 = 2 - 0.2j
print(type(c1), c1)  #  <class 'complex'> (1+0.1j)

c3 = c1+c2   # 复数加法， 3-0.1j
c4 = c1*c2   # 复数乘法， 2.02+0j
```

-------------------
## 4 布尔值/布尔类型
### （1）布尔类型（True、False）
布尔类型是计算机中最基本的类型，它是计算机二进制世界的体现，一切都是0和1。Python中的布尔类型只有两种值：True和False。
>**注意：** 首字母都是大写，与C++、JavaScript中的小写有所不同）

布尔类型回答的是是非问题，那么什么情况下是True，什么情况下是False呢？ Python里面实现了一个类型对象叫做bool，bool是一个int的子类，内置的True和False就是bool仅有的两个实例对象。


对对象进行布尔真假判断：
```python
a = bool(None)   # False
b = bool(0)      # False
c = bool([])     # False
d = bool({'a':[]})  # True
```


**判断假的情况有:**
- None, False
- 数值中的0, 0.0, 0j(虚数), Decimal(0), Fraction(0, 1)
- 空字符串('')、空元组(())、空列表([])
- 空字典({})、空集合(set())
- 对象默认为True，除非它有bool()方法且返回False或len()方法且返回0


### （2）布尔运算（and、or、not）

**优先级：**

- or, and, not的优先级是依次递增。所以 a or b and c 等价于 a or (b and c)。
- not的优先级比非布尔运算符低。所以 not a == b 等价于 not (a == b)，并且a == not b是语法错误。


-------------------
## 5 空值
Python 中，用 None 来表示空值。
numpy 中的 nan 也有类似的表示。


-------------------
## 6 字符串

### （1）新建
```python
line = '123 456 789'
```


### （2）拆分（.split）
```python
line = '123 456 789'
components = line.split(' ')       # 以空格拆分，components为序列list

audio_id, text = line.split(' ', 1)    # 
```

### （3）拼接（+）
```python
folder = 'I:/'
imgName = '11111.jpg'
pathImg = folder + '/' + imgName 
```

### （4）代替（.replace）
```python
filename = filename.replace('.mp3', '.wav')
```

### （5）删除（.strip）

**（a）去掉头尾多余字符（.strip）**
str.strip()就是把字符串(str)的头和尾的空格，以及位于头尾的\n \t之类给删掉。
```python
例1：
str=" ABC"
print(str.strip())

例2：
str = "\t AA"
print(str)
print(str.strip())

例3：
str2 = "\n AAAA"
print(str2)
print(str2.strip())

例4：
a= "\n ABC ABC ABC =========>KLJIFLJI \t \n"
print(a)
print(a.strip())
```
>**注意：**
不抓取字符串中间的空格，只抓头尾。可以发现空格躲在ABC中间去了，因为删除工作遇到了从头遇到了A，从尾遇到了C，因此就删到这里为止，中间的空格就不抓出来啦！

>**补充：**
字符串str还有另外两种类似的方法lstrip()和rstrip()。第一个是只删头，第二个是只删尾巴。



### （6）查找（.find、.index）

**（a）.find**
```python
ss = 'abca' 
b = ss.find('a') # 从下标0开始，查找在字符串里第一个出现的子串。 ：0 
c = ss.find('a',1) # 从下标1开始，查找在字符串里第一个出现的子串。：3 

b = ss.find('ab')   # : 0
c = ss.find('ca',1)  # : 2

d = ss.find('3') # ： -1 
```

**（b）.index**
```python
b = ss.index('a') # 从下标0开始，查找在字符串里第一个出现的子串。 ：0 
c = ss.index('a',1) # 从下标1开始，查找在字符串里第一个出现的子串。：3 

b = ss.index('ab')    # : 0
c = ss.index('ca',1)  # : 2

d = ss.index('3') # 找不到 报错
```

**（a）两类函数**
find(), rfind()
index(), rindex()

**（b）找到了都返回下标**
find找不到返回-1,index找不到抛出ValueError.



**（c）找出特定字串的个数**

```python
str1 = "abskfirgnlskgabndf"
str2 = "ab"
num = (len(str1) - len(str1.replace(str2,""))) // len(str2)
```

**（d）找出特定字串的所有位置**

```python
def find_sub_str(s, sub):
    out = []
    idx = s.find(sub)
    while idx != -1:
        out.append(idx)
        idx = s.find(sub, idx+1)
    return out
```

### （7）计数（.count）（子字符串）
```python
strs = "They look good and stick good!"
res = strs.count('good')
print(res)
```

### （8）字符串格式化(.format、zfill)
```python
# 任意类型： 数字，字符串
'log/{}/server_{}.log'.format(FLAGS.ip, FLAGS.port)

# 整数补0
"{0:03d}".format(1)     # 001
"1".zfill(3)            # 001

# 小数位数固定
"{:.2f}".format(12.2828)  # 12.28





```

### （9）比较
```python
Str1 = ‘111’
Str2 = ‘222’
if(Str1 == Str2):
```

### （10）转义字符（\）
```python
"Hello  \"W \"orld"      # 会输出  Hello "W"orld
```

### （11）str  <==>  bytes 

**（a） str  ==>  bytes**
```python
b = b"example"  # bytes object
s = "example"   # str object

sb = bytes(s, encoding = "utf8")
sb2 = str.encode(s)
```
**（b）  bytes  ==>  str**
```python
bs = str(b, encoding = "utf8")
bs2 = bytes.decode(b)
bs2 = str(b)


temp1 = line.decode('utf-8')
```

### （12）str  <==>  list

**（a） list ==> str**
```python
l = [[1, 2, 3], [1, 3], [3]]
s = str(l)
print(type(s), s)
print(type(s), s[:5]) 

<class 'str'> [[1, 2, 3], [1, 3], [3]]
<class 'str'> [[1, 
```

**（b） str ==> list**
```python
l2 = eval(s)
print(type(l2), l2)
<class 'list'> [[1, 2, 3], [1, 3], [3]]
```

**（c） str ==> bytes**
```python
# bytes object  
b = b"example"
# str object  
s = "example"  
# str to bytes  
sb = bytes(s, encoding = "utf8")  
# bytes to str  
bs = str(b, encoding = "utf8")  
# an alternative method  
# str to bytes  
sb2 = str.encode(s)  
# bytes to str  
bs2 = bytes.decode(b)
```


### （13）正则（re.search）


### （14）判断字符串中是否有汉字

```python
def is_chinese(string):
    """
    检查整个字符串是否包含中文
    :param string: 需要检查的字符串
    :return: bool
    """
    for ch in string:
        if u'\u4e00' <= ch <= u'\u9fff':
            return True

    return False

def count_chinese(string):
    """
    统计整个字符串中汉字的个数
    :param string: 需要检查的字符串
    :return: int
    """
    cnt = 0
    for ch in string:
        if u'\u4e00' <= ch <= u'\u9fff': 
            cnt += 1
    return cnt



if __name__ =='__main__':
    ret1 = is_chinese("刘亦菲")
    print(ret1)    # True

    ret2 = is_chinese("123")
    print(ret2)    # False
```



### （15）编辑距离（Levenshtein）
from：https://www.jb51.net/article/98449.htm

```python
import Levenshtein


def cal_similar(text_a, text_b):
    dist = Levenshtein.distance(text_a, text_b)  # 编辑距离
    len_text = len(text_a) + len(text_b)
    similar = (len_text - dist) / len_text      # 相似度
    return dist, len_text, similar

text_a = '艾伦 图灵传'
text_b = '艾伦•图灵传'
dist, len_text, similar = cal_similar(text_a, text_b)
print( dist, len_text, similar )


text_a = '图灵传'
text_b = '艾伦•图灵传'
dist, len_text, similar = cal_similar(text_a, text_b)
print( dist, len_text, similar )


# ----------------------------------- print ---------------------------------------
1 12 0.9166666666666666

3 9 0.6666666666666666
```



-------------------
## 7 类型判断（type、isinstance）
**（a）type**
```python
a = 10      	# int 整数
b = 1.3     	# float 浮点数
c = True    	# 真值 （True/False）
d = 'Hello' 	# 字符串str

print(a,type(a))
```

**（b）isinstance**

- **函数原型：** isinstance(object, classinfo)
- **参数：**
     - object： 实例对象。
     - classinfo： 可以是直接或间接类名、基本类型或者有它们组成的元组。
- **返回：** 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。

**常见数据类型判断：**
- 字符串、int、long、float: isinstance(data, (int, str, types.LongType, float))
- 时间类型: isinstance(data, datetime.datetime)
- 布尔类型: isinstance(data, (bool))
- 字典类型: isinstance(data, (dict))
- 数组: isinstance(data, (list))
- unicode: isinstance(data, unicode)
- mongo obJect: isinstance(data, bson.objectid.ObjectId)


**（c）type() 与 isinstance()区别**
```python
class A:
    pass   
class B(A):
    pass

isinstance(A(), A)    # returns True 
type(A()) == A        # returns True 
isinstance(B(), A)    # returns True 
type(B()) == A        # returns False
```

