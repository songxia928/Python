

- [其他数据类型](#其他数据类型)
  - [1 序列（tuple 、list）](#1-序列tuple-list)
    - [（1） 新建（[0] * n、range）](#1-新建0--nrange)
    - [（2） 拼接成字符串（''.join(list)）](#2-拼接成字符串joinlist)
    - [（3） 添加元素（.append、.extend、+）](#3-添加元素appendextend)
    - [（4） 删除元素（.remove、.pop、del）](#4-删除元素removepopdel)
    - [（5） 排序（.sort、sorted）](#5-排序sortsorted)
    - [（6） 反序（reversed）](#6-反序reversed)
    - [（7） 乱序（shuffle）](#7-乱序shuffle)
    - [（8） 查找元素（in、.index）](#8-查找元素inindex)
    - [（9） 清空list](#9-清空list)
    - [（10） 合并/拼接（+）， 分片](#10-合并拼接-分片)
    - [（11） 去重（set）](#11-去重set)
    - [（12） *list](#12-list)
  - [2 集合](#2-集合)
    - [（1）新建（{}，set()）](#1新建set)
    - [（2）加入（.add()，.update()）](#2加入addupdate)
    - [（3）删除（.remove()，.discard()，pop()）](#3删除removediscardpop)
    - [（4）长度（len()）](#4长度len)
    - [（5）清空（.clear()）](#5清空clear)
    - [（6）是否存在（in）](#6是否存在in)
    - [（7）集合运算（-，|，&，^）](#7集合运算-)
  - [3 字典](#3-字典)
    - [（1）新建（{}、.setdefault()、dict()、defaultdict）](#1新建setdefaultdictdefaultdict)
    - [（2）清空（.clear()）](#2清空clear)
    - [（3）拷贝（.copy()）](#3拷贝copy)
    - [（4）keys,vals ==> dict （.fromkeys()、  zip + dict()）](#4keysvals--dict-fromkeys--zip--dict)
    - [（5）items（“键值对”） ==> dict （ dict() ）](#5items键值对--dict--dict-)
    - [（6）dict ==> items（.items()）](#6dict--itemsitems)
    - [（7）返回所有key （.keys()）](#7返回所有key-keys)
    - [（8）返回所有value（.values()）](#8返回所有valuevalues)
    - [（9）返回指定key的val （.get()、 .setdefault()）](#9返回指定key的val-get-setdefault)
    - [（10）删除key-val，并返回val。 （ .pop() ）](#10删除key-val并返回val--pop-)
    - [（11）删除最后加入的元素，返回key-val。（.popitem()）](#11删除最后加入的元素返回key-valpopitem)
    - [（12）判断是否存在key（in）](#12判断是否存在keyin)
    - [（13）长度（len）](#13长度len)
    - [（14）最值（max(d, key=d.get)）](#14最值maxd-keydget)
    - [（14）字典深拷贝](#14字典深拷贝)
    - [（30）字典排序（sorted）](#30字典排序sorted)
    - [（31）str《=》字典 （json.loads(), eval(), str()）](#31str字典-jsonloads-eval-str)
    - [（32）拼接（dict(d1.items()+d2.tiems()), .update(d1), dict(d1, **d2)）](#32拼接dictd1itemsd2tiems-updated1-dictd1-d2)
    - [（33）字典计数 dic.get(i,0)](#33字典计数-dicgeti0)
    - [（34）字典 <==> namespace](#34字典--namespace)
  - [4 有序字典（OrderedDict）](#4-有序字典ordereddict)
    - [（1）把指定key-val移到最后。（.move_to_end()）](#1把指定key-val移到最后move_to_end)
  - [5 计数器（Counter）](#5-计数器counter)
    - [（1）创建Counter](#1创建counter)
    - [（2）统计元素个数](#2统计元素个数)
    - [（3）获取元素（.items）](#3获取元素items)
    - [（4）获取所有键key和value（.keys、.values）](#4获取所有键key和valuekeysvalues)
    - [（5）Conter 转 字典（dict）](#5conter-转-字典dict)
    - [（6）删除 元素(del)](#6删除-元素del)
    - [（7）从Counter恢复序列(.elements)](#7从counter恢复序列elements)
    - [（8）返回最多的k个数（.most_common）](#8返回最多的k个数most_common)
    - [（9）相加（.update、+）](#9相加update)
    - [（10）相减（.subtract、-）](#10相减subtract-)
    - [（11）相交（&）](#11相交)
    - [（12）合并（|）](#12合并)
    - [（13）清空](#13清空)
    - [（14）统计val的和](#14统计val的和)
    - [（15）移除val为0或负数的键值对（+）](#15移除val为0或负数的键值对)
    - [（16）移除val为0或正数的键值对（-）](#16移除val为0或正数的键值对-)


# 其他数据类型

## 1 序列（tuple 、list）
```python
# 序列有两种：tuple（定值表； 也有翻译为元组） 和 list (表)
s1 = (2, 1.3, 'love', 5.6, 9, 12, False)    # tuple 元组 元素不可变更
s2 = [True, 5, 'smile']                     # list 表 元素可变更
```

### （1） 新建（[0] * n、range）
**（a） 手动新建（[0] * n）**
```python
# 乘以对应中括号内维度，对应维度内的数据复制多份。
# === copy 一个数
n = 4
dp = [0] * n     # n，乘以括号里的维度，0复制n份，数值拷贝为深拷贝
print(dp)
dp[0], dp[1] = 1, 2
print(dp)
[0, 0, 0, 0]
[1, 2, 0, 0]

dp = [0 for _ in range(n)]  # 与 [0] * n等价 
print(dp)
dp[0], dp[1] = 1, 2
print(dp)
[0, 0, 0, 0]
[1, 2, 0, 0]

# === copy 一个list
dp = [[0]] * n    # n*1，乘以外面括号的维度，[0]复制n份，list拷贝为浅拷贝
print(dp)
dp[0][0], dp[3][0] = 1, 4
print(dp)
dp = [[0] for _ in range(n)] # n*1，用for深拷贝
print(dp)
dp[0][0], dp[3][0] = 1, 4
print(dp)
[[0], [0], [0], [0]]
[[4], [4], [4], [4]]
[[0], [0], [0], [0]]
[[1], [0], [0], [4]]

# === copy 两个数
dp = [1, 2] * n     # (2*n)
print(dp)
dp = [[1, 2]] * n   # n*2，浅拷贝
print(dp)
dp = [[1, 2] for _ in range(n)]   # n*2，用for深拷贝
print(dp)
[1, 2, 1, 2, 1, 2, 1, 2]
[[1, 2], [1, 2], [1, 2], [1, 2]]
[[1, 2], [1, 2], [1, 2], [1, 2]]

# === 二维数组
m = 3
dp = [[0] * n ] * m   # m*n，浅拷贝
print(dp)
dp[0][0], dp[0][1] = 1, 2
print(dp)
[ [0, 0, 0, 0], 
[0, 0, 0, 0], 
[0, 0, 0, 0] ]
[ [1, 2, 0, 0], 
[1, 2, 0, 0], 
[1, 2, 0, 0] ]

dp = [[0] * n  for _ in range(m) ]  # m*n，用for深拷贝
print(dp)
dp[0][0], dp[0][1] = 1, 2
print(dp)
[ [0, 0, 0, 0], 
[0, 0, 0, 0], 
[0, 0, 0, 0] ]
[ [1, 2, 0, 0], 
[0, 0, 0, 0], 
[0, 0, 0, 0] ]

# 左边上边为1
#      1*n     (m-1) * n
dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)] 
print(dp)
[[1, 1, 1, 1], 
[1, 0, 0, 0], 
[1, 0, 0, 0]]
```

**（b） 均匀数组（range）**

- **函数原型：** range（start， end， scan)
- **参数：**
           start:计数的开始位置，默认是从0开始。
           end: 计数的结束位置。
           scan：每次跳跃的间距，默认为1。
- **返回：** 并非是list，而是一个迭代器。
> **注意：** 返回的结果并不包含end。

```python
range(5)  # [0, 1, 2, 3, 4] 
range(0,6)   #  [0, 1, 2, 3, 4, 5]
range(0,10,2)   # [0, 2, 4, 6, 8]
range(4,-4,-1)  # [4, 3, 2, 1, 0, -1, -2, -3]
```

### （2） 拼接成字符串（''.join(list)）
```python
seq1 = ['hello','good','boy','doiido']
str1 = '_'.join(seq1)  # seq1元素需是字符串
str2 = ''.join(seq1)
```

### （3） 添加元素（.append、.extend、+）
```python
# ==== .append
list1 = ['a', 'b']
list2 = ['c', 'd']
list3 = ['e', 'f']
list4 = ['1', '2']

list1.append(list4)
print(list1)    # ['a', 'b', ['1', '2']]

# ==== .extend
list2.extend(list4)
print(list2)    # ['c', 'd', '1', '2']

# ==== + 
print(list3 + list4) # ['e', 'f', '1', '2']
```

### （4） 删除元素（.remove、.pop、del）

**（a） .remove: 删除单个元素，删除首个符合条件的元素，按值删除**
```python
str=[1,2,3,4,5,2,6]
str.remove(2)    # [1, 3, 4, 5, 2, 6]
```

**（b） .pop:  删除单个或多个元素，按位删除(根据索引删除)**
```python
>>> str=[0,1,2,3,4,5,6]
>>> str.pop(1)   #pop删除时会返回被删除的元素
1
>>> str
[0, 2, 3, 4, 5, 6]
>>> str2=['abc','bcd','dce']
>>> str2.pop(2)
'dce'
>>> str2
['abc', 'bcd']
```

**（c） del：它是根据索引(元素所在位置)来删除**
```python
>>> str=[1,2,3,4,5,2,6]
>>> del str[1]
>>> str
[1, 3, 4, 5, 2, 6]
>>> str2=['abc','bcd','dce']
>>> del str2[1]
>>> str2
['abc', 'dce']

除此之外，del还可以删除指定范围内的值。
>>> str=[0,1,2,3,4,5,6]
>>> del str[2:4]  #删除从第2个元素开始，到第4个为止的元素(但是不包括尾部元素)
>>> str
[0, 1, 4, 5, 6]

del 也可以删除整个数据对象(列表、集合等)
>>> str=[0,1,2,3,4,5,6]
>>> del str
>>> str         #删除后，找不到对象
```

Traceback (most recent call last):
  File "<pyshell#27>", line 1, in <module>
    str
NameError: name 'str' is not defined

>**注意：** del是删除引用(变量)而不是删除对象(数据)，对象由自动垃圾回收机制（GC）删除。


### （5） 排序（.sort、sorted）
**（a） 一维排序**
```python
a = [7, 3, 5 ,1]
b = sorted(a)                   # 从小到大，sorted不改变a，有返回
print(a, b)
b = sorted(a, reverse=True)     # 从大到小
print(a, b)
b = a.sort()                    # 从小到大, .sort改变a本身，无返回
print(a, b)
[7, 3, 5, 1] [1, 3, 5, 7]
[7, 3, 5, 1] [7, 5, 3, 1]
[1, 3, 5, 7] None
```

**（b） 二维排序**
```python
a = [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
b = sorted(a, key = lambda x: (-x[0], x[1]))  # 第0位降序，第1位升序
print(b)

a = [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
a.sort( key = lambda x: (-x[0], x[1]) )  
print(a)
[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]
[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]
```

**（c）返回排序后索引**
最好转换成numpy，再做。


**（d）元素为字符串的排序**
```python
def list_sort_string():  # 区分大小写
    a=["delphi","Delphi","python","Python","c++","C++","c","C","golang","Golang"]
    a.sort() #按字典顺序升序排列
    print("升序:",a)
    a.sort(reverse=True) #按降序排列
    print("降序:",a)

升序: ['C', 'C++', 'Delphi', 'Golang', 'Python', 'c', 'c++', 'delphi', 'golang', 'python']
降序: ['python', 'golang', 'delphi', 'c++', 'c', 'Python', 'Golang', 'Delphi', 'C++', 'C']


def list_sort_by_length():
    a=["delphi","Delphi","python","Python","c++","C++","c","C","golang","Golang"]
    a.sort(key=lambda ele:len(ele)) #按元素长度顺序升序排列
    print("升序:",a)
    list.sort(key=lambda ele:len(ele),reverse=True) #按降序
    print("降序:",list)

升序: ['c', 'C', 'c++', 'C++', 'delphi', 'Delphi', 'python', 'Python', 'golang', 'Golang']
降序: ['delphi', 'Delphi', 'python', 'Python', 'golang', 'Golang', 'c++', 'C++', 'c', 'C']

```


### （6） 反序（reversed）
```python
a = [1,2,5,4,3]

b = reversed(a)   # 迭代器
b1 = list(b)
b3 = a[: :-1] 

print('=====================')
print(type(b), b)
print(b1)
print('=====================')
print(b3)

=====================
<class 'list_reverseiterator'> <list_reverseiterator object at 0x000001C45B43F9B0>
[3, 4, 5, 2, 1]
=====================
[3, 4, 5, 2, 1]
```


### （7） 乱序（shuffle）
```python
from random import shuffle
L = [1, 2, 4, 5]
shuffle(L)
print(L)
```


### （8） 查找元素（in、.index）
**（a）in**
```python
if a in b:
```

**（b）.index**
list的index(object)返回 元素第一次出现的位置
```python
a = ["ab","cd",1,3]
print a.index(1)     # 输出就是2
```


**（c）二分查找（bisect）**
```python
import bisect

a = [1,4,6,8,12,15,20]
position = bisect.bisect(a,13)   # bisect 就是在调用 bisect_right
print(position)

a.insert(position,13)  # 用可变序列内置的insert方法插入
print(a)

a2 = [1,4,6,8,12,15,20]
bisect.insort(a2,13)  # 使用bisect.insort，比bisect先查找该插入哪个位置，再用insert方法插入更加快速的方法
print(a2)
5
[1, 4, 6, 8, 12, 13, 15, 20]
[1, 4, 6, 8, 12, 13, 15, 20]


L = [1,3,3,6,8,12,15]  
x = 3

x_insert_point = bisect.bisect_left(L, x)  #在L中查找x，x存在时返回x左侧的位置，x不存在返回应该插入的位置 
print(x_insert_point)  # 1
  
x_insert_point = bisect.bisect_right(L, x)  #在L中查找x，x存在时返回x右侧的位置，x不存在返回应该插入的位置
print(x_insert_point)  # 3
其目的在于查找该数值将会插入的位置并返回，而不会插入。如果x存在a中则返回x右边的位置
def bisect_right(a, x, lo=0, hi=None)
    # a 原列表
    # x 插入的元素
    # lo 起始位置 默认值为0
    # hi 结束位置 默认值为len(a)  

x_insort_left = bisect.insort_left(L, x)  #将x插入到列表L中，x存在时插入在左侧  
print(x_insort_left, L)  # None [1, 3, 3, 3, 6, 8, 12, 15]

x_insort_rigth = bisect.insort_right(L, x) #将x插入到列表L中，x存在时插入在右侧　　　　  
print(x_insort_rigth, L) # None [1, 3, 3, 3, 3, 6, 8, 12, 15]
```

**手写二分查找：**
```python
        def search(left, right): #二分查找一个数，[5,7,7,8,8,10]这种就有点麻烦
            while left <= right:
                pivot = (left + right) // 2
                if nums[pivot] == target:
                    return pivot
                else:
                    if target < nums[pivot]:
                        right = pivot - 1
                    else:
                        left = pivot + 1
            return -1

class Solution:
    def search_left(self, nums, target):  # 二分查找左边界
        lo = 0   # lo不需要为-1，因为mid是整除2，中点会和lo重合
        hi = len(nums) # 为了中点能比较到端点

        idx = -1
        F_in = False   # 标记位，标记是否在nums中
        while lo < hi:  # 当lo=hi，结束循环
            mid = (lo + hi) // 2  # 中点坐标
            if nums[mid] == target :   # 中点 = target，选左半边
                F_in = True
                hi = mid
            elif nums[mid] > target : # 中点 > target，选左半边
                hi = mid
            else:
                lo = mid+1
        if F_in : idx = lo
        
        return idx

    def search_right(self, nums, target):  # 二分查找右边界
        lo = 0
        hi = len(nums) 
        
        idx = -1
        F_in = False
        while lo < hi:
            mid = (lo + hi) // 2  # 中点坐标
            if nums[mid] == target :   # 中点 = target，选左右边
                F_in = True
                lo = mid+1
            elif nums[mid] > target : # 中点 > target，选左半边
                hi = mid
            else:
                lo = mid+1
        if F_in : idx = hi-1   # nums[hi]大于target,所以需要-1
        
        return idx

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if (not nums) or nums[0] > target or nums[-1] < target: # 为空或 不在范围内
            return [-1, -1]
        
        left_idx = self.search_left(nums, target)        
        if left_idx == -1: return [-1, -1]
        
        right_idx = self.search_right(nums, target)

        return [left_idx, right_idx]
```


### （9） 清空list
```python
Imgs.clear()
```

### （10） 合并/拼接（+）， 分片
**（a） 合并**
```python
List3 = List1 + List2
```

**（b） 分片**
```python


```


### （11） 去重（set）
```python
set1=set([1,2,3,4])
set2=set(['A','B','D','C'])
set3=set(['A','C', 'B', 'D'])
set4=set(['A','B','D','C','B'])
print('1.',set1)
print('2.',set2)
print('3.',set3)
print('4.',set4)

{1, 2, 3, 4}
{'A', 'C', 'B', 'D'}
{'A', 'C', 'B', 'D'}
{'A', 'C', 'B', 'D'}
```

>**注意：**
这里set后的查询，只需要O(1)时间（哈希查找）。正常情况下是O(n)。
	哈希查找：构造字典，以数的地址为key，数的位置为val。

    为什么哈希\字典查找是O(1)？

### （12） *list
● 列表前面加星号作用是将列表解开成两个独立的参数，传入函数
● 字典前面加两个星号，是将字典解开成独立的元素作为形参
```python
def add(a, b):
    return a + b

if __name__ == '__main__':
    #  ==== d1
    d1 = [4, 3]
    print('== d1:', d1)
    print('== *d1:', *d1)
    
    print(add(*d1))
    
    #  ==== d2
    d2 = {'a': 4, 'b': 3}
    print('== d2:', d2)
    '''
    d2_tp = **d2
    print('== **d2:', d2_tp2)
    '''
    
    print(add(**d2))
```


## 2 集合
集合（set）是一个无序的不重复元素序列。
Python和Java中，集合的插入、查找都依赖于哈希，时间复杂度固定。
### （1）新建（{}，set()）
可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。

```python
set_a = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(type(set_a), set_a)
<class 'set'> {'banana', 'orange', 'apple', 'pear'}

# set list
list1 = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
set_a = set(list1)
print(type(set_a), set_a)
<class 'set'> {'banana', 'orange', 'apple', 'pear'}
# set str
set_a = set('abracadabra')
print(type(set_a), set_a)
<class 'set'> {'d', 'a', 'c', 'b', 'r'}
```
### （2）加入（.add()，.update()）
```python
# add 元素
set_a = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
set_a.add( 'orange' )
print(set_a)
set_a.add( 'crabgrass' )
print(set_a)
{'banana', 'orange', 'apple', 'pear'}
{'orange', 'pear', 'crabgrass', 'banana', 'apple'}

# update 集合 。还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等
set_a = set(("Google", "Runoob", "Taobao"))
set_a.update({1,3})  
print(set_a)
set_a.update([1,4],[5,6]) # s.update( x )可以有多个，用逗号分开
print(set_a)
{'Taobao', 1, 'Runoob', 3, 'Google'}
{'Taobao', 1, 'Runoob', 3, 4, 5, 6, 'Google'}
```

### （3）删除（.remove()，.discard()，pop()）
```python
# remove 指定元素
set_a = set(("Google", "Runoob", "Taobao"))
set_a.remove("Taobao")
print(set_a)
'''
set_a.remove("Facebook")   # 不存在会发生错误
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Facebook'
'''
{'Google', 'Runoob'}
# discard 指定元素
set_a = set(("Google", "Runoob", "Taobao"))
set_a.discard("Facebook")  # 不存在不会发生错误
print(set_a)
{'Taobao', 'Google', 'Runoob'}
# pop 随机删除
set_a = set(("Google", "Runoob", "Taobao"))
print(set_a)
set_a.pop()
print(set_a)#多次执行测试结果都不一样。
# set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。
{'Taobao', 'Google', 'Runoob'}
{'Google', 'Runoob'}
```

### （4）长度（len()）
```python
set_a = set(("Google", "Runoob", "Taobao"))
print(len(set_a))
3
```

### （5）清空（.clear()）
```python
set_a = set(("Google", "Runoob", "Taobao"))
set_a.clear()
print(set_a)
set()
```

### （6）是否存在（in）
集合没有list中 a.index(‘x’)的功能。
```python
set_a = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print('orange' in set_a)
print('crabgrass' in set_a)
True
False
```

### （7）集合运算（-，|，&，^）
```python
a = set('123')
b = set('234')
print(a)         
print(b)
print(a-b)  # 集合a中包含而集合b中不包含的元素
print(a|b)  # 集合a或b中包含的所有元素
print(a&b)  # 集合a和b中都包含了的元素
print(a^b)  # 不同时包含于a和b的元素
{'2', '3', '1'}
{'2', '4', '3'}
{'1'}
{'4', '3', '2', '1'}
{'2', '3'}
{'4', '1'}
```

**集合内置方法完整列表：**

| 方法                  | 描述 |
| ---                   | --- |
| add()                 | 为集合添加元素 |
| clear()               | 移除集合中的所有元素 |
| copy()                | 拷贝一个集合 |
| difference()          | 返回多个集合的差集 |
| difference_update()   | 移除集合中的元素，该元素在指定的集合也存在 |
| discard()             | 删除集合中指定的元素 |
| intersection()        | 返回集合的交集 |
| intersection_update() | 返回集合的交集 |
| isdisjoint()          | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False |
| issubset()            | 判断指定集合是否为该方法参数集合的子集 |
| issuperset()          | 判断该方法的参数集合是否为指定集合的子集 |
| pop()                 | 随机移除元素 |
| remove()              | 移除指定元素 |
| symmetric_difference() | 返回两个集合中不重复的元素集合 |
| symmetric_difference_update() | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中 |
| union()               | 返回两个集合的并集 |
| update()              | 给集合添加元素 |	



## 3 字典
键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行
不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
```python
dict = {'Name': 'Zara', 'Age': 7, 'Name': 'Manni'} 
print( "dict['Name']: ", dict['Name'])
dict['Name']:  Manni
```

### （1）新建（{}、.setdefault()、dict()、defaultdict）
**（a）一般（dic['k1'] = 'v1'）**
```python
dic = {}
# dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
dic['k3'] = 'v3'
print(dic)
{'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}
#OrderedDict([('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')]) #OrderedDict()的输出
```

**（b）.setdefault()**
```python
# =====字典设置默认值
x = {}
x.setdefault(1, 0)   # 设置条目默认值，初始化字典
print(x)
{1: 0}
x[2] = 10
print(x)
{1: 0, 2: 10}
x.setdefault(2, 1)  # 无法改变key为 2 的val
print(x)
{1: 0, 2: 10}
x.setdefault(3, 1) # 可以新加
print(x)
{1: 0, 2: 10, 3: 1}
```

**（c）dict()**
```python
>>>dict()                        # 创建空字典 
{} 
>>> dict(a='a', b='b', t='t')     # 传入关键字 
{'a': 'a', 'b': 'b', 't': 't'} 
>>> dict(zip(['one', 'two', 'three'], [1, 2, 3]))   # 映射函数方式来构造字典 
{'three': 3, 'two': 2, 'one': 1}  
>>> dict([('one', 1), ('two', 2), ('three', 3)])    # 可迭代对象方式来构造字典 {'three': 3, 'two': 2, 'one': 1} 

a_list = ['one', 'two', 'three']
b_list = [1, 2, 3]
dic = dict(a_list=a_list, b_list=b_list)     # 传入关键字 
print(dic)
{'a_list': ['one', 'two', 'three'], 'b_list': [1, 2, 3]}
```


**（d）defaultdict**
使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict：
```python
from collections import defaultdict
like = defaultdict(list)  #   新建空字典

from collections import defaultdict

dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'

print(dd['key1']) # key1存在
print(dd['key2']) # key2不存在，返回默认值
```
注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。
除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。

```python
# 找出个数为1 的数
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        hash_table = defaultdict(int) # 新建哈希表
        for num in nums:
            print(hash_table[num])  # 如果不存在num，则返回0
            hash_table[num] += 1   # 以num为key，num的个数为val

        for num in hash_table: # 遍历key
            if hash_table[num] == 1:
                return num
```


### （2）清空（.clear()）
```python
dic = {}
# dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
dic.clear()
print(dic)
{}
# OrderedDict()   # OrderedDict()的输出
```

### （3）拷贝（.copy()）
```python
dic = {}
# dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
new_dic = dic.copy()
print(new_dic)
{'k1': 'v1', 'k2': 'v2'}
# OrderedDict([('k1', 'v1'), ('k2', 'v2')])  # OrderedDict()的输出
```

### （4）keys,vals ==> dict （.fromkeys()、  zip + dict()）
**（a） .fromkeys()**
```python
dic = {}
#dic = OrderedDict()
name = ['tom','lucy','sam']
age = [12, 1, 3]
print(dic.fromkeys(name))
print(dic.fromkeys(name, 20))
print(dic.fromkeys(name, age))
{'tom': None, 'lucy': None, 'sam': None}
{'tom': 20, 'lucy': 20, 'sam': 20}
{'tom': [12, 1, 3], 'lucy': [12, 1, 3], 'sam': [12, 1, 3]}  
#OrderedDict([('tom', None), ('lucy', None), ('sam', None)])  # OrderedDict()
#OrderedDict([('tom', 20), ('lucy', 20), ('sam', 20)])
#OrderedDict([('tom', [12, 1, 3]), ('lucy', [12, 1, 3]), ('sam', [12, 1, 3])])
```
**（b） dict()**
```python
x = [1, 2, 3]
y = ["one", "two", "three"]
z = zip(x,y)
dic = dict(z)            # dict是实例化字典，不要用dict命名变量
#dic = OrderedDict(z)
print(z)
print(dic)
<zip object at 0x000001358C032588>
{1: 'one', 2: 'two', 3: 'three'}
#OrderedDict([(1, 'one'), (2, 'two'), (3, 'three')]) # OrderedDict()
```

### （5）items（“键值对”） ==> dict （ dict() ）
```python
dic = {2:'b', 1:'a', 3:'c'}
items = dic.items()
print(items)

dic1 = dict(items)
dic2 = dict( list(items) )      # 转换成list，再转字典
#dic1 = OrderedDict(items)
#dic2 = OrderedDict( list(items) ) 
print(dic1)
print(dic2)
dict_items([(2, 'b'), (1, 'a'), (3, 'c')])
{2: 'b', 1: 'a', 3: 'c'}
{2: 'b', 1: 'a', 3: 'c'}
#OrderedDict([(2, 'b'), (1, 'a'), (3, 'c')])    # OrderedDict()的输出
#OrderedDict([(2, 'b'), (1, 'a'), (3, 'c')])
```

### （6）dict ==> items（.items()）
```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
print(dic.items())   # 变成列表需要加list
dict_items([('k1', 'v1'), ('k2', 'v2')])
# odict_items([('k1', 'v1'), ('k2', 'v2')])  # OrderedDict()的输出

# ==== items 到 keys和vals
items_list = list(items) # 必须转换成list，才能提取key和val
keys = items_list[:][0] 
vals = items_list[:][1]
print(keys)
print(vals)
('k1', 'v1')
('k2', 'v2')
```

### （7）返回所有key （.keys()）
```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
print(dic.keys())  
dict_keys(['k1', 'k2'])
# odict_keys(['k1', 'k2'])       # OrderedDict()的输出
```

### （8）返回所有value（.values()）
```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
dic['k3'] = 'v3'
print(dic.values())
dict_values(['v1', 'v2', 'v3'])
# odict_values(['v1', 'v2', 'v3'])    # OrderedDict()的输出
```

### （9）返回指定key的val （.get()、 .setdefault()）
.get()不存在key时，不创建新的key-val。而.setdefault()创建。

**（a）.get()**

- **语法：** dict.get(key, default=None)
- **参数：**
          key -- 字典中要查找的键。
          default -- 如果指定键的值不存在时，返回该默认值。default不能是序列。


```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'

val = dic.get('k2') # 存在
print(val)
val = dic.get('k3') # 不存在，返回None   
print(val, dic)
val = dic.get('k3', 0) # 不存在，返回0    
print(val, dic)
v2
None {'k1': 'v1', 'k2': 'v2'}
0 {'k1': 'v1', 'k2': 'v2'}
#v2                                          # OrderedDict()的输出
#None OrderedDict([('k1', 'v1'), ('k2', 'v2')])
#0 OrderedDict([('k1', 'v1'), ('k2', 'v2')])
```

**（b）.setdefault()**
```python
val = dic.setdefault('k2')    # 存在
print(val, dic)
val = dic.setdefault('k4')    # 不存在，则创建，val=None
print(val, dic)
val = dic.setdefault('k5', 0) # 不存在，则创建，val=0
print(val, dic)
v2
None {'k1': 'v1', 'k2': 'v2', 'k4': None}
0 {'k1': 'v1', 'k2': 'v2', 'k4': None, 'k5': 0}
#v2                                                  # OrderedDict()的输出
#None OrderedDict([('k1', 'v1'), ('k2', 'v2'), ('k4', None)])
#0 OrderedDict([('k1', 'v1'), ('k2', 'v2'), ('k4', None), ('k5', 0)])
```

### （10）删除key-val，并返回val。 （ .pop() ）
```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
dic['k3'] = 'v3'
val = dic.pop('k2')
print(val, dic)
v2 {'k1': 'v1', 'k3': 'v3'}
#v2 OrderedDict([('k1', 'v1'), ('k3', 'v3')])    # OrderedDict()的输出
```

### （11）删除最后加入的元素，返回key-val。（.popitem()）
```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
dic['k3'] = 'v3'
print(dic.popitem(), dic)     # 默认后进先出。链表删除，时间复杂度 O(1)
print(dic.popitem(last=False), dic) #先进先出。删除最先加入的键对。
 ('k3', 'v3') {'k1': 'v1', 'k2': 'v2'}
TypeError: popitem() takes no keyword arguments   # 字典报错
#('k3', 'v3') OrderedDict([('k1', 'v1'), ('k2', 'v2')]) # OrderedDict()的输出
#('k1', 'v1') OrderedDict([('k2', 'v2')])         # 有序字典不报错
```

### （12）判断是否存在key（in）
```python
dic = {}
#dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
if 'k1' in dic: print(' in ')    # 哈希查找，时间复杂度 O(1)
else:           print(' not in ')

if 'k4' in dic: print(' in ')
else:           print(' not in ')
in 
not in
```

### （13）长度（len）
```python
dic = {1:'a', 2:'b', 3:'c'}
dic2 = OrderedDict(dic)     # 字典 初始化 有序字典
dic3 = dict(dic2)            # 有序字典 初始化 字典
print(dic)
print(dic2)
print(dic3)
{1: 'a', 2: 'b', 3: 'c'}
OrderedDict([(1, 'a'), (2, 'b'), (3, 'c')])
{1: 'a', 2: 'b', 3: 'c'}

n = len(dic)
n2 = len(dic2)
print(n)
print(n2)
3
3
```

### （14）最值（max(d, key=d.get)）
**（a）key_maxKey**
```python
# 返回字典中key最大值
d = {2:'a', 3:'b', 1:'c'}
key_maxKey = max(d)  # 不加key函数的话，默认遍历的是字典的key，输出最大的键
print(key_maxKey)
3
```
**（b）key_maxVal**
```python
# 返回字典中value最大值对应的key
d = {2:'a', 3:'b', 1:'c'}
key_maxVal = max(d, key=d.get) # O(n)?, 加key表示，遍历的是value，找到最大的value，返回对应key
print(key_maxVal)
key_maxVal = max(d, key=lambda k: d[k])  # 同 d.get
print(key_maxVal)
1
1
```
### （14）字典深拷贝
https://blog.csdn.net/LeonTom/article/details/82761319


### （30）字典排序（sorted）
**（a）先取items再排序**
```python
# 先取items再排序
dic = {2:'b', 1:'c', 3:'a', 4:'a', -1:'a'}
items0 = sorted(dic.items(), key=lambda x: x[0])  # 对items中key排序。升序
items1 = sorted(dic.items(), key=lambda x: x[1])  # 对items中val排序。升序
print(items0)
print(items1)              # 如果val相等，并不再对key排序
[(-1, 'a'), (1, 'c'), (2, 'b'), (3, 'a'), (4, 'a')]
[(3, 'a'), (4, 'a'), (-1, 'a'), (2, 'b'), (1, 'c')]

def dic_sort_by_val_up(dic):
    items1 = sorted(dic.items(), key=lambda x: x[1])  # 对items中val排序。升序
    dic_new = dict(items1)
    return dic_new
    
def dic_sort_by_val_down(dic):
    items1 = sorted(dic.items(), key=lambda x: x[1])[::-1]  # 对items中val排序。降序
    dic_new = dict(items1)
    return dic_new


def dic_sort_by_key_up(dic):
    items0 = sorted(dic.items(), key=lambda x: x[0])  # 对items中key排序。升序
    dic_new = dict(items0)
    return dic_new
    
def dic_sort_by_key_down(dic):
    items0 = sorted(dic.items(), key=lambda x: x[0])[::-1]   # 对items中key排序。降序
    dic_new = dict(items0)
    return dic_new
```

**（b）先取keys再按key排序**
```python
# 对key排序，从小打大，并返回排序后的key和val序列
def sort_key(dic):
    keys = dic.keys()
    new_keys = sorted(keys)
    new_vals = [dic[key]  for key  in new_keys]
    return new_keys, new_vals

dic = {2:'b', 1:'a', 3:'c'}
new_keys, new_vals = sort_key(dic)
print(new_keys, new_vals)  
[1, 2, 3] ['a', 'b', 'c']
```

### （31）str《=》字典 （json.loads(), eval(), str()）
**（a）str =》字典**

```python
# ======== json.loads()
import json
d_str = '{"name":"john", "gender":"male", "age":28}'
# d_str = '{1:"a", 2:"b", 3:"c"}'  # 这个会报错
d_dic = json.loads(d_str)
print(type(d_dic), d_dic)
<class 'dict'> {'name': 'john', 'gender': 'male', 'age': 28}

d_str = "{'name':'john', 'gender':'male', 'age': 28}"  # 单引号在里面，会报错
d_dic = json.loads(d_str)
print(type(d_dic), d_dic)

# ========  eval()
#d_str = '{"name" : "john", "gender" : "male", "age": 28}'
d_str = '{1:"a", 2:"b", 3:"c"}'   # 两个都不会错
d_dic = eval(d_str)  
print(type(d_dic), d_dic)
<class 'dict'> {1: 'a', 2: 'b', 3: 'c'}

```

**（b）字典 =》str （str()）**
```python
d_dic = {1:'a', 2:'b', 3:'c'}
d_dic2 = OrderedDict(dic)
d_str = str(d_dic)
d_str2 = str(d_dic2)
print(type(d_str), d_str)  
print(type(d_str), d_str2)   # 有序字典，最好不要直接用str。可以先转成字典
<class 'str'> {1: 'a', 2: 'b', 3: 'c'}
<class 'str'> OrderedDict([(1, 'a'), (2, 'b'), (3, 'c')])
```

### （32）拼接（dict(d1.items()+d2.tiems()), .update(d1), dict(d1, **d2)）

https://www.cnblogs.com/lmh001/p/9888156.html

**（a）dict(d1.items()+d2.tiems())**
（这个在python3.6 不好用）

**（b）.update(d1)**

**（c）dict(**d1, **d2) ， d3 = dict(d1, **d2)**


>**注意：**
d1 和 d2 两个字典中存在相同key时，dict(**d1, **d2)会报错：
TypeError: type object got multiple values for keyword argument  


### （33）字典计数 dic.get(i,0)
```python
li = ['a','a','a','b','b','b','c','c','d']
dic = {}
for i in li:
    dic[i] = dic.get(i,0) + 1

{'a': 3, 'b': 3, 'c': 2, 'd': 1}
```

### （34）字典 <==> namespace 


**（a）字典 ==> namespace (argparse、munch)**

1）argparse
```python
import argparse
b = argparse.Namespace(**dic)
```

2）munch
https://blog.csdn.net/weixin_30894389/article/details/99624590
作用：将字典转化成支持 a.b的方式获取属性

```python
from munch import Munch
b = Munch({'hello': 'world'})  
```

**（b）namespace ==》字典 （vars）**

1）vars
```python
dic = vars(ns)
```




## 4 有序字典（OrderedDict）
字典和链表的综合结构。使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用OrderedDict 。
注意：OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：
from collections import OrderedDict

```
#### （1）新建
（同字典）
#### （2）清空（.clear()）
（同字典）
#### （3）拷贝（.copy()）
（同字典）
#### （4）list 到 dict。（.fromkeys(), zip + OrderedDict()）
（同字典）
#### （5）items（“键值对”） 到 dict。（OrderedDict()）
（同字典）
#### （6）dict 到 items（.items()）
（同字典）
#### （7）返回所有key（.keys()）
（同字典）
#### （8）返回所有val（.values()）
（同字典）
#### （9）返回指定key的val（.get()  .setdefault()）
（同字典）
#### （10）删除key-val，并返回val。（.pop()）
（同字典）
#### （11）删除最后加入的元素，返回key-val。（.popitem()）
（见字典，有点不一样）
#### （12）判断是否存在key（in）
（同字典）
#### （13）长度（len）
（同字典）
```

### （1）把指定key-val移到最后。（.move_to_end()）
```python
dic = OrderedDict()
dic['k1'] = 'v1'
dic['k2'] = 'v2'
dic['k3'] = 'v3'
dic.move_to_end('k1')    # 时间复杂度 O(1)。字典没有这个属性
print(dic)
OrderedDict([('k2', 'v2'), ('k3', 'v3'), ('k1', 'v1')])
```


## 5 计数器（Counter）
from collections import Counter

### （1）创建Counter
```python
c = Counter()             # 创建一个空的Counter对象 
print('[0]===0:', type(c), c)  

str1 = 'programming'
c = Counter(str1)   # 使用 可迭代对象 初始化Counter对象 
print('[0]===1:', c)

c1 = Counter()
for ch in str1:
     c1[ch] = c1[ch] + 1    #  一个一个统计
print('[0]===1:', c1)

c = Counter({'red': 4, 'blue': 2})   # 使用 映射对象 初始化Counter对象 
print('[0]===2:', c)

c = Counter(cats=4, dogs=8)  # 使用 关键字参数 初始化Counter对象 
print('[0]===3:', c)
print('[0]===3:', c['cats'])

[0]===0: <class 'collections.Counter'> Counter()
[0]===1: Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})
[0]===2: Counter({'red': 4, 'blue': 2})
[0]===3: Counter({'dogs': 8, 'cats': 4})
[0]===3: 4
```

### （2）统计元素个数
```python
a = ['eggs', 'ham', 'eggs']
c2 = Counter(a) 
print('[1]===0:', c2) 
print('[1]===1:', c2['eggs'])
print('[1]===2:', c2['bacon'])   # 获取Counter对象中不存在的元素的值value，不会报错KeyError，而是返回0

[1]===0: Counter({'eggs': 2, 'ham': 1})
[1]===1: 2
[1]===2: 0
```

### （3）获取元素（.items）
```python
c = Counter(a=4, b=2, c=0, d=-2)
items = c.items()                        # 转换成包含类似(elem, cnt)元素的列表 
l1 = list(items)
print(type(items), items)
print('[x]===0:', l1)
<class 'dict_items'> dict_items([('a', 4), ('b', 2), ('c', 0), ('d', -2)])
[x]===0: [('a', 4), ('b', 2), ('c', 0), ('d', -2)]
```

### （4）获取所有键key和value（.keys、.values）
```python
c = Counter(a=4, b=2, c=0, d=-2)
l1 = list(c)               # 以列表的形式展现Counter对象的所有键key
print('[x]===0:', l1)
 [x]===0: ['a', 'b', 'c', 'd']

key = c.keys()
val = c.values()
print('[x]===0:', type(key), key, type(val), val)
 [x]===0: <class 'dict_keys'> dict_keys(['a', 'b', 'c', 'd']) <class 'dict_values'> dict_values([4, 2, 0, -2])

c = Counter(a=4, b=2, c=0, d=-2)
l1 = set(c)                # 以 集合 的形式展现Counter对象的所有键key
print('[x]===1:', l1)
[x]===1: {'c', 'd', 'a', 'b'}
```

### （5）Conter 转 字典（dict）
```python
c2 = dict(c)                             # 将Counter对象转换成字典
print('[x]===1:', c2)
[x]===1: {'a': 4, 'b': 2, 'c': 0, 'd': -2}
```

### （6）删除 元素(del)
```python
a = ['eggs', 'ham', 'eggs']
c2 = Counter(a) 
c2['sausage'] = 0  # 如果给Counter对象中的某个元素赋值为0，并不意味着这个元素被删除了
print('[2]===0:',c)  # 如果想删除Counter中的某个元素，使用del

del c['sausage']  
print('[2]===1:',c)  
[2]===0: Counter({'a': 4, 'b': 2, 'c': 0, 'd': -2})
[2]===1: Counter({'a': 4, 'b': 2, 'c': 0, 'd': -2})
```

### （7）从Counter恢复序列(.elements)
```python
c3 = Counter(a=4, b=2, c=0, d=-2)  
c3_e1 = c3.elements()    # 返回一个迭代器
c3_e2 = c3.elements()
l1 = sorted(c3_e1)
l2 = list(c3_e2)

print('[3]===0:', c3)
print('[3]===1:', c3_e1)
print('[3]===1:', c3_e2)
print('[3]===2:', l1)   
print('[3]===2:', l2) 
[3]===0: Counter({'a': 4, 'b': 2, 'c': 0, 'd': -2})
[3]===1: <itertools.chain object at 0x0000016A0A0742B0>
[3]===1: <itertools.chain object at 0x0000016A0A074D68>
[3]===2: ['a', 'a', 'a', 'a', 'b', 'b']
[3]===2: ['a', 'a', 'a', 'a', 'b', 'b']
```

### （8）返回最多的k个数（.most_common）
```python
c4 = Counter('abracadabra')
l3 = c4.most_common(3)  # 返回一个列表，里面的元素都是以元组的形式存在
print('[4]===0:', l3)   # 元组里的元素分别是原先Counter对象中的键值对

n = 2
l3 = c4.most_common()[:-n-1:-1]       # 找出数量最少的n个元素
print('[4]===0:', l3)   
[4]===0: [('a', 5), ('b', 2), ('r', 2)]
[4]===0: [('d', 1), ('c', 1)]
```

### （9）相加（.update、+）
```python
c7 = Counter(a=4, b=2, c=0, d=-2)
c8 = Counter(a=1, b=2, c=3, d=4, e=5, f=-1)  
c10 = c7 + c8              # 只保留最后value值为正的元素
c7.update(c8)  
print('[6]===0:', c10)   
print('[6]===1:', c7) 
[6]===0: Counter({'a': 5, 'e': 5, 'b': 4, 'c': 3, 'd': 2})
[6]===1: Counter({'a': 5, 'e': 5, 'b': 4, 'c': 3, 'd': 2, 'f': -1})
```

### （10）相减（.subtract、-）
```python
c5 = Counter(a=4, b=2, c=0, d=-2)
c6 = Counter(a=1, b=2, c=3, d=4, e=5)
c9 = c5 - c6              # 只保留最后value值为正的元素
c5.subtract(c6)
print('[5]===0:', c9) 
print('[5]===1:', c5)  
[5]===0: Counter({'a': 3})
[5]===1: Counter({'a': 3, 'b': 0, 'c': -3, 'e': -5, 'd': -6})
```

### （11）相交（&）
```python
c5 = Counter(a=4, b=2, c=0, d=-2)
c6 = Counter(a=1, b=2, c=3, d=4, e=5, f=-1)
c9 = c5 & c6              # 相交，只保留相同的元素和最小的value值
print('[7]===0:', c9)  
 [7]===0: Counter({'b': 2, 'a': 1})
```

### （12）合并（|）
```python
c5 = Counter(a=4, b=2, c=0, d=-2)
c6 = Counter(a=1, b=2, c=3, d=4, e=5, f=-1)
c9 = c5 | c6              # 合并，保留相同元素和最大的value值，包含不相同的元素
print('[8]===0:', c9)  
 [8]===0: Counter({'e': 5, 'a': 4, 'd': 4, 'c': 3, 'b': 2})
```

### （13）清空
```python
c = Counter(a=4, b=2, c=0, d=-2)
c.clear()                            # 清空Counter对象里面的所有元素
 [9]===0: Counter()
```

### （14）统计val的和
```python
c = Counter(a=4, b=2, c=0, d=-2, f=-1)
sum1 = sum(c.values())                 # 统计所有元素的个数， 会把小于1的也算进去
print(sum1)
3
```

### （15）移除val为0或负数的键值对（+）
```python
c2 = +c                              # 将数量为0或负数的键值对给移除   
print(c2)
Counter({'a': 4, 'b': 2})
```

### （16）移除val为0或正数的键值对（-）
```python
c2 = -c                              # 将数量为0或正数的键值对给移除，并将数量为负数的元素变成整数
print(c2)
Counter({'d': 2, 'f': 1})
```


