
- [22.Python 实现](#22python-实现)
  - [1 排序](#1-排序)
    - [（1） 快排](#1-快排)
    - [（2）堆排序](#2堆排序)
    - [（3） 归并排序](#3-归并排序)
    - [（4） 桶排序](#4-桶排序)




# 22.Python 实现
----------------------------------------------


## 1 排序
**排序算法的稳定性：**
若待排序的序列中，存在多个具有相同关键字的记录，经过排序，这些记录的相对次序保持不变，则称该算法是稳定的；
若经排序后，记录的相对次序发生了改变，则称该算法是不稳定的。
r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

**稳定性的意义：**
- 1）只是简单的进行数字的排序，那么稳定性将毫无意义。
- 2）以某种关键字的方式排序后，能不影响到其他关键字原来排序结果的方法就是稳定的。比如一开始按照价格高低排序结果为 a(10元，卖了5个) b(8元，卖了20个) c(6元，卖了20个) d(4元，卖了30个),则按照销量重拍后如果保持 d(30个,价格为4元) b(20个，价格为8元) c(20个，价格为6元) a(5个，价格为10元)，则说明该方法为稳定的，而如果出现c在b前，破坏了排序前b在c前的顺序，则说明这个方法是不稳定的

### （1） 快排
**（a）原理（双指针+二分法+递归）**

**算法过程：**
- 1） 选取每段第一个为参考值mid。
- 2） 双指针往中间搜索：
    -  左指针往中间寻找第一个大于mid,交换其和mid。
    -  进入右边，右指针往中间搜索，寻找到第一个小于mid的数，交换其与mid。
    -  进入左边，重复上面的操作，知道左右指针相遇，则左右指针左边的小于mid，右边的大于mid。
- 3）以左右指针的位置为分界点，分割数组为左右两个部分，分别递归重复步骤1、2。

**（b）复杂度**
时间复杂度：O(nlogn)。极端情况是，遍历所有的都要交换。
空间复杂度：O(logn)，递归时的栈深度。

**（c）Python**
```python
def quick_sort(nums):

    def func_QuickSort(nums, start, end):
        if start >= end:# 递归停止条件
            return
        
        mid = nums[start] # 设置起始元素为要寻找位置的基准元素
        left = start # 左指针
        right = end  # 右指针
        while left < right:
            # 找到右边第一个小于mid的值
            while left < right and nums[right] >= mid: 
                right -= 1
            nums[left] = nums[right] # 将找到的值赋值给左边
            # left=right 和 nums[right]<mid 处理情况一样

            # 找到左边第一个大于mid的值
            while left < right and nums[left] < mid:# 则left向右移动
                left += 1
            nums[right] = nums[left]  # 将找到的值赋值给右边

        nums[left] = mid  # 将基准元素放到该位置
        # 此时 左边 <= mid <= 右边 
        
        func_QuickSort(nums, start, left-1) # 递归左侧，不包括mid点
        func_QuickSort(nums, left+1, end)   # 递归右侧，不包括mid点

    func_QuickSort(nums, 0, len(nums)-1)

if __name__ == '__main__':
    nums = [23, 94, 2, 21, 56, 6]
    quick_sort(nums)  # 原地排序，不新建新的数组
    print(nums)
```

### （2）堆排序
**（a）原理（堆）**

**堆的性质：**
- 大顶堆（大跟堆）和小根堆（小根堆）是一颗每一个节点的键值都不小于（大于）其孩子节点的键值的树。
- 大根堆还是小根堆（前提是二叉堆）都可以看成是一颗完全二叉树。
- 在大小为 k 的堆中插入一个元素消耗log(k) 时间。

算法过程：
1）找到最后面一个父节点 first = int(n/2-1) ，n为数组长度。
2）构建大顶堆。从最后一个父节点往前遍历所有父节点。遍历中每次都要对堆进行调整，以下是堆调整（堆顶插入）的过程：
3）每次遍历的节点作为堆的根（父）节点，也就是起始位置，截至位置n-1不变。
4）比较父节点和左右孩子节点中较大的节点。
5）如果父节点大，则保持。
3）如果父节点小，则交换父节点和较大的孩子节点。
? 更新父节点指针指向较大孩子节点的位置。重复比较其和其较大孩子节点，指导其没有孩子节点。
? 下次迭代新加入的根节点，作为新的数插入原来的堆中。
3）依次输出堆的最大值。依次从后往前遍历所有数，其位置作为堆的截至位置，初始位置0不变。
? 交换堆截至位置0和end 的值，最大值去了数组末尾。
? 调整堆，剩余的堆中找到最大值放到0位置。用于下次交换。
? 更新堆的截至点。

**（b）复杂度**
时间复杂度：O(nlogn)。构建堆用了nlogn，输出也用了nlogn。
空间复杂度：O(1)。

**（c）Python**
```python
def heap_sort(ary):

    #大顶堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点
    def max_heapify(ary, start, end): #start为当前需要调整最大堆的位置，end为调整边界
        root = start
        while True:
            child = root * 2 + 1    #左子节点
            if child > end:
                break
            if child + 1 <= end and ary[child] < ary[child+1]: #取较大的子节点
                child = child + 1 
                
            if ary[root] < ary[child]:    #较大的子节点成为父节点
                ary[root], ary[child] = ary[child], ary[root]
                root = child  # 将当前较大子节点位置给root。
                # 如果下一轮child不越界，则相当于迭代向下处理上原本根的子节点
                # 又因为是从最后一个父系节点开始遍历，所以遍历下一个父节点时，其子节点已经处理好了。
            else:
                break
    
    n = len(ary)
    first = int(n/2-1)    #最后一个非叶子节点
    for start in range(first, -1, -1):    # 构建最大堆
        max_heapify(ary, start, n-1)
    # 此时，最大堆已经构建完成，ary[0]是最大数

    for end in range(n-1, 0, -1):    # 将最大跟堆转换成有序数组
        # 将根节点元素与最后叶子节点进行互换，取出最大根节点元素，对剩余节点重新构建最大堆
        ary[end], ary[0] = ary[0], ary[end]  
        max_heapify(ary, 0, end-1)   
    return ary

if __name__ == '__main__':
    nums = [23, 94, 2, 21, 56, 6]
    heap_sort(nums)  # 原地排序，在原数组上构建堆，未重新定义堆结构，升序
    print(nums) 
```


### （3） 归并排序
**（a）原理**

**（b）复杂度**

**（c）Python**


### （4） 桶排序
**（a）原理**

**（b）复杂度**

**（c）Python**






