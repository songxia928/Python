




# 迭代器、生成器、装饰器
https://blog.csdn.net/sunchengquan/article/details/84494101
## 1 生成器

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

## 2 迭代器

可以直接作用于for循环的数据类型有以下几种：
? 一类是集合数据类型，如list、tuple、dict、set、str等。
? 一类是generator ，包括生成器和带yeild的generator function。

可迭代对象（Iterable）：这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。
迭代器（Iterator）：可以被next()函数调用并不断返回下一个值的对象称为迭代器。List、dict、str虽然是Iterable，却不是Iterator。




## 3 装饰器

python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。
https://blog.csdn.net/xiangxianghehe/article/details/77170585


### （1）高阶函数+嵌套函数 = 装饰器 （func_timeout、lru_cache）
**（a）func_timeout （超时函数）**
```python
import func_timeout
import time

from func_timeout import func_set_timeout


func_set_timeout(5)
def f():
    while True:
        print( "1")
        time.sleep(1)


if __name__ == '__main__':
    try:
        f()
    except func_timeout.exceptions.FunctionTimedOut:
        print("timeout!" )
```

> **注意：** 
 - （1）多线程中，当 @func_set_timeout（）用来装饰 线程函数时，外面的异常捕获一定要加上   except func_timeout.exceptions.FunctionTimedOut:  ，因为正常的 except Exception as e: 中，异常不会被捕获。
 - （2）单进程中不会有这个问题。


**（b） lru_cache**
通过用键值对的防止将数据放到字典中，如果下次需要取值时可以直接到字典中获取，不需要重新计算，这部分数据（缓存）不会被立即释放。
在 Python 的 3.2 版本中，引入了一个非常优雅的缓存机器，即 functool 模块中的 lru_cache 装饰器。如果要在 python2 中使用 lru_cahce 需要安装 functools32。
lru_cache 原型如下：
functools.lru_cache(maxsize=None, typed=False)
Maxsize：最多可以缓存maxsize 个此函数的调用结果，从而提高程序执行的效率，特别适合于耗时的函数。参数maxsize为最多缓存的次数，如果为None，则无限制，设置为2n时，性能最佳；
typed：如果 typed=True（注意，在 functools32 中没有此参数），则不同参数类型的调用将分别缓存，例如 f(3) 和 f(3.0)

```
from functools import lru_cache
lru_cache(None)
def add(x, y):
    print("calculating: %s + %s" % (x, y))
    return x + y
 
print(add(1, 2))
print(add(1, 2))
print(add(2, 3))

calculating: 1 + 2
3
3
calculating: 2 + 3
5
```

从结果可以看出，当第二次调用 add(1, 2) 时，并没有真正执行函数体，而是直接返回缓存的结果。
此外，有一个用 C 实现的，更快的，同时兼容 Python2 和 Python3 的第三方模块 fastcache（https://github.com/pbrady/fastcache） 能够实现同样的功能。



**（c）app.route，flask 装饰器**
    @app.route('/cv_test', methods=['POST', 'GET'])
    @app.route('/cv_test/download/<filename>', methods=['POST', 'GET'])


### （2）类装饰器


### （4）类方法 装饰器

classmethod,@staticmethod,@property


**（a）@classmethod

https://blog.csdn.net/yzxnuaa/article/details/79862386


**作用：**
等于先调用get_date（）对字符串进行处理，然后才使用Data_test的构造函数初始化。
以后重构类的时候不必要修改构造函数，只需要额外添加你要处理的函数，然后使用装饰符 @classmethod 就可以





