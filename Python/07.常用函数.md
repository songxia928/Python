




# 6 常用函数（map、reduce、filter、lamda、列表推导式等）
## 1 map 
map(function, sequence)，作用是将一个列表映射到另一个列表
```python
#l = list( range(1,10) )  # python3 中range是一个迭代器，需要list
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# ====== Map
def square(x):
    return x * x

a = list( map(square,l) ) # map的返回结果：<map object at 0x00020> 
print(a)

[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

## 2 reduce
reduce(function, sequence, startValue)，作用是将一个列表归纳为一个输出
```python
# ====== Reduce函数
from functools import reduce

def add(x,y):
    return 10*x+y
a = reduce(add, l)
print(type(a), a)
a = reduce(add, l, 10)
print(type(a), a)

<class 'int'> 123456789
<class 'int'> 10123456789
```
## 3 filter
filter(function, sequence)，作用是按照所定义的函数过滤掉列表中的一些元素。
```python
# ======== Filter函数
def is_odd(x):
    return x % 2 == 1
a = list( filter(is_odd, l) )
print(a)
[1, 3, 5, 7, 9]
```

## 4 lambda （匿名函数）
https://www.cnblogs.com/curo0119/p/8952536.html

lambda <参数>: 函数体，隐函数，定义一些简单的操作，可以结合map、reduce、filter来使用。省去起函数名，长用于只调用一次的函数。
```python
# ======= Lambda函数
f3 = lambda x: x**2
a = f3(2)
print(a)
b = list( map(f3, l) )
print(b)

4
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### 6.4 列表推导式
基本形式：[x for item in sequence <if (conditions)>], 这里x表示对item的操作。
```python
# =====列表推导式
a = [i**2 for i in l]
print(a)

[1, 4, 9, 16, 25, 36, 49, 64, 81]

```




## 6 其他函数


### 6.3 时间（time、datetime）
（1）time
```python
time_start=time.time()
cnt_error = upload_image_file(Path3, Path2_save, token_ret)
time_end=time.time()
time_cost = time_end-time_start     # 单位秒
print('totally cost',time_cost)

time.sleep(time_cost)   # 单位秒



t = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))  # 当前日期 当前时间

```
（2）datetime
```python
from datetime import date, timedelta

today = data.today()

yesterday = (date.today() + timedelta(days=-1)).strftime("%Y-%m-%d")
print(yesterday)

tomorrow = (date.today() + timedelta(days= 1)).strftime("%Y-%m-%d") 
print(tomorrow)
```




### 6.4 print
#### （1）打印字符串

```python
string="hello"    
#%s打印时结果是hello    
print "string=%s" % string      # output: string=hello    
    
#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是hello    
print "string=%2s" % string     # output: string=hello    
    
#%7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，    
#所以%7s的打印结果是  hello    
print "string=%7s" % string     # output: string=  hello    
    
#%-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，    
#所以%-7s的打印结果是  hello    
print "string=%-7s!" % string     # output: string=hello  !    
    
#%.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是he    
print "string=%.2s" % string    # output: string=he    
    
#%.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身，    
#所以%.7s的打印结果是hello    
print "string=%.7s" % string    # output: string=hello    
    
#%a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，    
#当截取的字符串长度小于a时，还需要在其左侧补空格    
print "string=%7.2s" % string   # output: string=     he    
print "string=%2.7s" % string   # output: string=hello    
print "string=%10.7s" % string  # output: string=     hello    
    
#还可以用%*.*s来表示精度，两个*的值分别在后面小括号的前两位数值指定    
print "string=%*.*s" % (7,2,string)      # output: string=     he    
```


#### （2）打印整形

```python
num=14    
#%d打印时结果是14    
print "num=%d" % num            # output: num=14    
    
#%1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印，所以%1d的打印结果还是14    
print "num=%1d" % num           # output: num=14    
    
#%3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格，所以%3d的打印结果是 14    
print "num=%3d" % num           # output: num= 14    
    
#%-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格，所以%3d的打印结果是14_    
print "num=%-3d" % num          # output: num=14_    
    
#%05d意思是打印结果为5位整数，当整数的位数不够5位时，在整数左侧补0，所以%05d的打印结果是00014    
print "num=%05d" % num          # output: num=00014    
    
#%.3d小数点后面的3意思是打印结果为3位整数，    
#当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果是014    
print "num=%.3d" % num          # output: num=014    
    
#%.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数，    
#当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果还是014    
print "num=%.0003d" % num       # output: num=014    
    
#%5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，再在左侧补空格，    
#规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是  014    
print "num=%5.3d" % num         # output: num=  014    
    
#%05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，    
#由于是05，再在左侧补0，最终的长度选数值较大的那个，所以%05.3d的打印结果还是00014    
print "num=%05.3d" % num        # output: num=00014    
    
#还可以用%*.*d来表示精度，两个*的值分别在后面小括号的前两位数值指定    
#如下，不过这种方式04就失去补0的功能，只能补空格，只有小数点后面的3才能补0    
print "num=%*.*d" % (04,3,num)  # output: num= 014    
```


#### （3）打印浮点型

```python
import math    
    
#%a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度    
    
#只是%f时表示原值，默认是小数点后5位数    
print "PI=%f" % math.pi             # output: PI=3.141593    
    
#只是%9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格    
print "PI=%9f" % math.pi            # output: PI=_3.141593    
    
#只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0    
print "PI=%03.f" % math.pi          # output: PI=003    

#%6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格    
print "PI=%6.3f" % math.pi          # output: PI=_3.142    
    
#%-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格    
print "PI=%-6.3f" % math.pi         # output: PI=3.142_    
    
#还可以用%*.*f来表示精度，两个*的值分别在后面小括号的前两位数值指定    
#如下，不过这种方式06就失去补0的功能，只能补空格    
print "PI=%*.*f" % (06,3,math.pi)   # output: PI=_3.142    ```
```

#### （3）打印字典（pprint）
from: https://blog.csdn.net/ancan9144/article/details/101791730
```python
import pprint
count = {}
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
for character in message:
    count.setdefault(character,0)
    count[character] = count[character] +1
pprint.pprint(count)
```

#### （2） 打印对象
```python
def prn_obj(obj):
    print( '\n'.join(['%s:%s' % item for item in obj.__dict__.items()]) )
```




### 6.5 三元条件运算符

    n_max = a if a>b else b   # 相当于 n_max = max(a, b)， 好像没有C++中的  ex1？ex2：ex3

### 6.5 枚举
```python
for i, path1 in enumerate(paths1):


alist = ['a1', 'a2', 'a3'] 
blist = ['b1', 'b2', 'b3']  
for i, (a, b) in enumerate(zip(alist, blist)):    # 枚举两个
     print(i, a, b)
```


### 6.5 next()
我们首先要知道什么是可迭代的对象（可以用for循环的对象）Iterable：
一类：list，tuple，dict，set，str
二类：generator，包含生成器和带yield的generatoe function

而生成器不但可以作用于for，还可以被next()函数不断调用并返回下一个值，可以被next()函数不断返回下一个值的对象称为迭代器：Iterator

生成器都是Iterator对象，但list，dict，str是Iterable，但不是Iterator，要把list，dict，str等Iterable转换为Iterator可以使用iter()函数

next()用法：
next(iterator[, default])
iterator – 可迭代对象
default – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。

```python
a = [1,2,3,4]
b = iter(a)
print('================')
print(type(b))
for i in range(4):
    print(next(b))

b = iter(a)
print('================')
print(type(b))
for i in range(5):
    print(next(b, -1))


================
<class 'list_iterator'>
1
2
3
4
================
<class 'list_iterator'>
1
2
3
4
-1
```

### 6.5 zip()
当zip()函数中只有一个参数时，zip(iterable)从迭代器中依次取一个元组，组成一个元组。
```python
list1 = [1, 2, 3, 4]
tuple1 = zip(list1)
print(type(tuple1))
print(list(tuple1))
<class 'zip'>
[(1,), (2,), (3,), (4,)]

m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
n = [[1, 1, 1], [2, 2, 3], [3, 3, 3]]
p = [[1, 1, 1], [2, 2, 2]]
print(list(zip(m,n)))
print(list(zip(m,p)))
[([1, 2, 3], [1, 1, 1]), ([4, 5, 6], [2, 2, 3]), ([7, 8, 9], [3, 3, 3])]
[([1, 2, 3], [1, 1, 1]), ([4, 5, 6], [2, 2, 2])]

m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
n = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
# 矩阵的点乘
C = [x*y for a, b in zip(m, n) for x, y in zip(a, b)]
# 矩阵相加
D = [x+y for a, b in zip(m, n) for x, y in zip(a, b)]
print(C)
print(D)
[1, 2, 3, 8, 10, 12, 21, 24, 27]
[2, 3, 4, 6, 7, 8, 10, 11, 12]
```
### 6.5 zip(*f)

dict(zip(("input_ids", "input_mask", "segment_ids", "label_ids"), zip(*features)))

### 6.5 yield()



### 6.5 __()


### 6.5 不同文件间有全局变量吗？



### 6.5 try

异常名称	描述
BaseException	所有异常的基类
SystemExit	解释器请求退出
KeyboardInterrupt	用户中断执行(通常是输入^C)
Exception	常规错误的基类
StopIteration	迭代器没有更多的值
GeneratorExit	生成器(generator)发生异常来通知退出
StandardError	所有的内建标准异常的基类
ArithmeticError	所有数值计算错误的基类
FloatingPointError	浮点计算错误
OverflowError	数值运算超出最大限制
ZeroDivisionError	除(或取模)零 (所有数据类型)
AssertionError	断言语句失败
AttributeError	对象没有这个属性
EOFError	没有内建输入,到达EOF 标记
EnvironmentError	操作系统错误的基类
IOError	输入/输出操作失败
OSError	操作系统错误
WindowsError	系统调用失败
ImportError	导入模块/对象失败
LookupError	无效数据查询的基类
IndexError	序列中没有此索引(index)
KeyError	映射中没有这个键
MemoryError	内存溢出错误(对于Python 解释器不是致命的)
NameError	未声明/初始化对象 (没有属性)
UnboundLocalError	访问未初始化的本地变量
ReferenceError	弱引用(Weak reference)试图访问已经垃圾回收了的对象
RunError	一般的运行时错误
NotImplementedError	尚未实现的方法
SyntaxError	Python 语法错误
IndentationError	缩进错误
TabError	Tab 和空格混用
SystemError	一般的解释器系统错误
TypeError	对类型无效的操作
ValueError	传入无效的参数
UnicodeError	Unicode 相关的错误
UnicodeDecodeError	Unicode 解码时的错误
UnicodeEncodeError	Unicode 编码时错误
UnicodeTranslateError	Unicode 转换时错误
Warning	警告的基类
DeprecationWarning	关于被弃用的特征的警告
FutureWarning	关于构造将来语义会有改变的警告
OverflowWarning	旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning	关于特性将会被废弃的警告
RuntimeWarning	可疑的运行时行为(runtime behavior)的警告
SyntaxWarning	可疑的语法的警告
UserWarning	用户代码生成的警告
func_timeout.exceptions.FunctionTimedOut	  装饰器 @func_set_timeout(5) 的 超时异常


```python
s = input('请输入除数:')
try:
    result = 20 / int(s)
    print('20除以%s的结果是: %g' % (s , result))
except ValueError:
    print('值错误，您必须输入数值')
except ArithmeticError:
    print('算术错误，您不能输入0')
except IndexError:
    print('索引错误：运行程序时输入的参数个数不够')
except Exception:
    print('未知异常')
else:
    print('没有出现异常')
```






### 6.2 断言函数（assert）

```python
assert expression     #  assert的语法格式

if not expression:      #  它的等价语句为
    raise AssertionError 
```
 
1、assert语句用来声明某个条件是真的。
2、如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert语句是应用在这种情形下的理想语句。
3、当assert语句失败的时候，会引发一AssertionError。

   有时候与其让程序在晚些时候崩溃，不如在错误条件出现时直接让它崩溃，如果需要在程序中的某个条件一定为真的时候才能让程序正常工作的话，assert语句就有用了，它可以在程序中置入检查点。
```python
age = 1  
assert 0<age<10  
age = -1  
assert 0<age<10  
```
当执行最后一句的时候，assert 0<age<10 失败，所以触发AssertionError，显示结果如下：  
Traceback (most recent call last):  
  File "<ipython-input-4-5ad9ee6f8005>", line 1, in <module> 
    assert 0<age<10  


### 6.4 编辑距离（Levenshtein）
from：https://www.jb51.net/article/98449.htm




### 6.4 数据增强
#### （1）augLy （facebook 开源）


### 6.4 python 执行shell命令
os.system  os.popen  subprocess.Popen 区别： https://my.oschina.net/u/4112543/blog/4617701  https://blog.csdn.net/yu97271486/article/details/104878616
    os.system： 返回状态码
    os.popen： 返回文件对象（保存输出结果），可以实现管道操作。通过read/readlines 实现阻塞。
    subprocess.Popen： 用来代替 os.popen



### 6.4 argparse
```python

    import  argparse
	
    parser = argparse.ArgumentParser()
    # Required parameters
                        help="Name of this run. Used for monitoring.")
    parser.add_argument("--dataset", choices=["cifar10", "cifar100","eproduct"],
                        default="eproduct",
                        help="Which downstream task.")
    parser.add_argument("--output_dir", default="output", type=str,
                        help="The output directory where checkpoints will be written.")
    parser.add_argument("--img_size", default=304, type=int,
                        help="Resolution size")

    args = parser.parse_args()
```



