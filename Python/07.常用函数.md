
- [07.常用函数（map、reduce、filter、lamda、列表推导式等）](#07常用函数mapreducefilterlamda列表推导式等)
  - [1 映射（map）](#1-映射map)
  - [2 归纳（reduce）](#2-归纳reduce)
  - [3 过滤（filter）](#3-过滤filter)
  - [4 匿名函数（lambda）](#4-匿名函数lambda)
  - [5 时间、日期（time、datetime）](#5-时间日期timedatetime)
    - [（1）time](#1time)
    - [（2）datetime](#2datetime)
    - [6 打印](#6-打印)
    - [（1）打印字典（pprint）](#1打印字典pprint)
      - [（2） 打印对象](#2-打印对象)
    - [6.5 枚举（enumerate、zip）](#65-枚举enumeratezip)
    - [6.5 next()](#65-next)
    - [6.5 zip()](#65-zip)
    - [6.5 zip(\*f)](#65-zipf)
    - [6.5 yield()](#65-yield)
    - [6.5 \_\_()](#65-__)
    - [6.5 不同文件间有全局变量吗？](#65-不同文件间有全局变量吗)
    - [6.5 try](#65-try)
    - [6.2 断言函数（assert）](#62-断言函数assert)
    - [6.4 数据增强](#64-数据增强)
      - [（1）augLy （facebook 开源）](#1augly-facebook-开源)
    - [6.4 python 执行shell命令](#64-python-执行shell命令)
    - [参数输入 到python 脚本 （argparse， sys.argv）](#参数输入-到python-脚本-argparse-sysargv)
    - [6.4 argparse](#64-argparse)
    - [6.4 sys.argv\[\]](#64-sysargv)



# 07.常用函数（map、reduce、filter、lamda、列表推导式等）

---------------------------------------------------------

## 1 映射（map） 
map(function, sequence)，作用是将一个列表映射到另一个列表
```python
#l = list( range(1,10) )  # python3 中range是一个迭代器，需要list
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# ====== Map
def square(x):
    return x * x

a = list( map(square,l) ) # map的返回结果：<map object at 0x00020> 
# ---------------------------- print ------------------------

[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

---------------------------------------------------------

## 2 归纳（reduce）
reduce(function, sequence, startValue)，作用是将一个列表归纳为一个输出
```python
from functools import reduce

l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def add(x,y):
    return 10*x+y

a = reduce(add, l)
b = reduce(add, l, 10)

print(type(a), a)
print(type(b), b)
# ---------------------------- print ------------------------

<class 'int'> 123456789
<class 'int'> 10123456789
```

---------------------------------------------------------

## 3 过滤（filter）
filter(function, sequence)，作用是按照所定义的函数过滤掉列表中的一些元素。
```python
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def is_odd(x):
    return x % 2 == 1

a = list( filter(is_odd, l) )
# ---------------------------- print ------------------------

[1, 3, 5, 7, 9]
```

---------------------------------------------------------

## 4 匿名函数（lambda）
https://www.cnblogs.com/curo0119/p/8952536.html

lambda <参数>: 函数体，隐函数，定义一些简单的操作，可以结合map、reduce、filter来使用。省去起函数名，长用于只调用一次的函数。
```python
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

f3 = lambda x: x**2

a = f3(2)
b = list( map(f3, l) )
# ---------------------------- print ------------------------

4
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```




## 5 时间、日期（time、datetime）
### （1）time
```python
import time

t0 = time.time()
time.sleep(1.2)   # 延时，单位秒
t1 = time.time()
cost = t1 - t0     # 统计时间，单位秒
print('totally cost: ', cost)


t = time.strftime('%Y-%m-%d_%H:%M:%S', time.localtime(time.time()))  # 当前日期 当前时间，转换成字符
print(t)

# ---------------------------- print ------------------------
totally cost:  1.209291696548462
2022-09-10_17:42:29
```

### （2）datetime
```python
from datetime import date, timedelta

today = date.today()
yesterday = (date.today() + timedelta(days=-1)).strftime("%Y-%m-%d")
tomorrow = (date.today() + timedelta(days= 1)).strftime("%Y-%m-%d") 
# ---------------------------- print ------------------------

2022-09-10
2022-09-09
2022-09-11


# ==== 获得 上个月
def get_last_month(split='-'):
    import datetime
    today = datetime.date.today()  # 1. 获取「今天」
    first = today.replace(day=1)  # 2. 获取当前月的第一天
    last_month = first - datetime.timedelta(days=1)  # 3. 减一天，得到上个月的最后一天
    last_month = last_month.strftime("%Y-%m".format(split))    # 4. 格式化成指定形式
    return last_month




```



### 6 打印

### （1）打印字典（pprint）
from: https://blog.csdn.net/ancan9144/article/details/101791730
```python
import pprint
count = {}
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
for character in message:
    count.setdefault(character,0)
    count[character] = count[character] +1
pprint.pprint(count)
```

#### （2） 打印对象
```python
def prn_obj(obj):
    print( '\n'.join(['%s:%s' % item for item in obj.__dict__.items()]) )
```


### 6.5 枚举（enumerate、zip）
```python
for i, path1 in enumerate(paths1):


alist = ['a1', 'a2', 'a3'] 
blist = ['b1', 'b2', 'b3']  
for i, (a, b) in enumerate(zip(alist, blist)):    # 枚举两个，zip可以多个
     print(i, a, b)
```


### 6.5 next()
我们首先要知道什么是可迭代的对象（可以用for循环的对象）Iterable：
一类：list，tuple，dict，set，str
二类：generator，包含生成器和带yield的generatoe function

而生成器不但可以作用于for，还可以被next()函数不断调用并返回下一个值，可以被next()函数不断返回下一个值的对象称为迭代器：Iterator

生成器都是Iterator对象，但list，dict，str是Iterable，但不是Iterator，要把list，dict，str等Iterable转换为Iterator可以使用iter()函数

next()用法：
next(iterator[, default])
iterator – 可迭代对象
default – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。

```python
a = [1,2,3,4]
b = iter(a)
print('================')
print(type(b))
for i in range(4):
    print(next(b))

b = iter(a)
print('================')
print(type(b))
for i in range(5):
    print(next(b, -1))


================
<class 'list_iterator'>
1
2
3
4
================
<class 'list_iterator'>
1
2
3
4
-1
```

### 6.5 zip()
当zip()函数中只有一个参数时，zip(iterable)从迭代器中依次取一个元组，组成一个元组。

```python
list1 = [1, 2, 3, 4]
tuple1 = zip(list1)
print(type(tuple1))
print(list(tuple1))
<class 'zip'>
[(1,), (2,), (3,), (4,)]

m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
n = [[1, 1, 1], [2, 2, 3], [3, 3, 3]]
p = [[1, 1, 1], [2, 2, 2]]
print(list(zip(m,n)))
print(list(zip(m,p)))
[([1, 2, 3], [1, 1, 1]), ([4, 5, 6], [2, 2, 3]), ([7, 8, 9], [3, 3, 3])]
[([1, 2, 3], [1, 1, 1]), ([4, 5, 6], [2, 2, 2])]

m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
n = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
# 矩阵的点乘
C = [x*y for a, b in zip(m, n) for x, y in zip(a, b)]
# 矩阵相加
D = [x+y for a, b in zip(m, n) for x, y in zip(a, b)]
print(C)
print(D)
[1, 2, 3, 8, 10, 12, 21, 24, 27]
[2, 3, 4, 6, 7, 8, 10, 11, 12]
```
### 6.5 zip(*f)

dict(zip(("input_ids", "input_mask", "segment_ids", "label_ids"), zip(*features)))

### 6.5 yield()



### 6.5 __()


### 6.5 不同文件间有全局变量吗？



### 6.5 try

异常名称	描述
BaseException	所有异常的基类
SystemExit	解释器请求退出
KeyboardInterrupt	用户中断执行(通常是输入^C)
Exception	常规错误的基类
StopIteration	迭代器没有更多的值
GeneratorExit	生成器(generator)发生异常来通知退出
StandardError	所有的内建标准异常的基类
ArithmeticError	所有数值计算错误的基类
FloatingPointError	浮点计算错误
OverflowError	数值运算超出最大限制
ZeroDivisionError	除(或取模)零 (所有数据类型)
AssertionError	断言语句失败
AttributeError	对象没有这个属性
EOFError	没有内建输入,到达EOF 标记
EnvironmentError	操作系统错误的基类
IOError	输入/输出操作失败
OSError	操作系统错误
WindowsError	系统调用失败
ImportError	导入模块/对象失败
LookupError	无效数据查询的基类
IndexError	序列中没有此索引(index)
KeyError	映射中没有这个键
MemoryError	内存溢出错误(对于Python 解释器不是致命的)
NameError	未声明/初始化对象 (没有属性)
UnboundLocalError	访问未初始化的本地变量
ReferenceError	弱引用(Weak reference)试图访问已经垃圾回收了的对象
RunError	一般的运行时错误
NotImplementedError	尚未实现的方法
SyntaxError	Python 语法错误
IndentationError	缩进错误
TabError	Tab 和空格混用
SystemError	一般的解释器系统错误
TypeError	对类型无效的操作
ValueError	传入无效的参数
UnicodeError	Unicode 相关的错误
UnicodeDecodeError	Unicode 解码时的错误
UnicodeEncodeError	Unicode 编码时错误
UnicodeTranslateError	Unicode 转换时错误
Warning	警告的基类
DeprecationWarning	关于被弃用的特征的警告
FutureWarning	关于构造将来语义会有改变的警告
OverflowWarning	旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning	关于特性将会被废弃的警告
RuntimeWarning	可疑的运行时行为(runtime behavior)的警告
SyntaxWarning	可疑的语法的警告
UserWarning	用户代码生成的警告
func_timeout.exceptions.FunctionTimedOut	  装饰器 @func_set_timeout(5) 的 超时异常


```python
s = input('请输入除数:')
try:
    result = 20 / int(s)
    print('20除以%s的结果是: %g' % (s , result))
except ValueError:
    print('值错误，您必须输入数值')
except ArithmeticError:
    print('算术错误，您不能输入0')
except IndexError:
    print('索引错误：运行程序时输入的参数个数不够')
except Exception as e:
    print(' ### Exception: ', e)
else:
    print('没有出现异常')
```






### 6.2 断言函数（assert）

```python
assert expression     #  assert的语法格式

if not expression:      #  它的等价语句为
    raise AssertionError 
```
 
1、assert语句用来声明某个条件是真的。
2、如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert语句是应用在这种情形下的理想语句。
3、当assert语句失败的时候，会引发一AssertionError。

   有时候与其让程序在晚些时候崩溃，不如在错误条件出现时直接让它崩溃，如果需要在程序中的某个条件一定为真的时候才能让程序正常工作的话，assert语句就有用了，它可以在程序中置入检查点。
```python
age = 1  
assert 0<age<10  
age = -1  
assert 0<age<10  
```
当执行最后一句的时候，assert 0<age<10 失败，所以触发AssertionError，显示结果如下：  
Traceback (most recent call last):  
  File "<ipython-input-4-5ad9ee6f8005>", line 1, in <module> 
    assert 0<age<10  





### 6.4 数据增强
#### （1）augLy （facebook 开源）


### 6.4 python 执行shell命令
os.system  os.popen  subprocess.Popen 区别： https://my.oschina.net/u/4112543/blog/4617701  https://blog.csdn.net/yu97271486/article/details/104878616
    os.system： 返回状态码
    os.popen： 返回文件对象（保存输出结果），可以实现管道操作。通过read/readlines 实现阻塞。
    subprocess.Popen： 用来代替 os.popen






### 参数输入 到python 脚本 （argparse， sys.argv）
如果是两层，或者两层混用，会怎样？



### 6.4 argparse
```python

def get_args():
    import  argparse
	
    parser = argparse.ArgumentParser()
    # Required parameters

    parser.add_argument("--dataset", choices=["cifar10", "cifar100","eproduct"],
                        default="eproduct",
                        help="Which downstream task.")
    parser.add_argument("--output_dir", default="output", type=str,
                        help="The output directory where checkpoints will be written.")
    parser.add_argument("--img_size", default=304, type=int,
                        help="Resolution size")

    #args = parser.parse_args()
    args, unknown = parser.parse_known_args()

    return args


args = get_args()


```


### 6.4 sys.argv[]
```python

#  运行 python ./test.py aa bb cc   
 
import sys
 
  
def main(argv): 
    print(argv[0])                  aa      
    print(argv[1])                  bb
    print(argv[1:])                 ['bb', 'cc']
    print(argv[1][1:])              b
  
    print('sys.argv[0]：',sys.argv[0])        #test1.py
    print('sys.argv[1]：',sys.argv[1])        #aa
    print('sys.argv[1：]：',sys.argv[1:])     #['aa', 'bb', 'cc']
  
    print('sys.argv:',sys.argv)                 #['test1.py', 'aa', 'bb', 'cc']
    print('type(sys.argv):',type(sys.argv))     #<class 'list'>
    print('len(sys.argv):',len(sys.argv))       #4 
 
    return 0  

if __name__ == '__main__':  
    sys.exit(main(sys.argv[1:]))  #sys.exit(0)正常退出， sys.exit(1)非正常退出


```


